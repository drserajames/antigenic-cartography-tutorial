---
title: "Antigenic cartography using Racmacs"
output: html_document
date: "2024-02-23"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction


1. Creating a map
2. Plotting a map
3. Quality assuring a map

I'm assuming you have a basic understanding of antigenic cartography. If not, you can learn more [here](https://acorg.github.io/Racmacs/articles/intro-to-antigenic-cartography.html)

## Making a map

```{r library}
library(ggplot2)

library(Racmacs)
options(RacOptimizer.num_cores = parallel::detectCores())
```


### Reading in data

First we need to read some data in. The way to read data in depends on the format.

```{r readin}
data1 <- read.csv("data/small-dataset.csv", row.names=1)
# replace "/" in sera names
colnames(data1) <- gsub(".", "/", colnames(data1), fixed=T) 
```

```{r make-acmap}
map <- acmap(titer_table = data1)
```

### Making a map

You don't always get the same map as the starting coordinates are random - that's why we run many optimisations. Before each map-making, I'm setting a random seed so the answer is reproducible.

```{r seed}
ran_seed <- 5387
```

You can make the map directly from the table or from the acmap object we just created. These methods are effectively equivalent.

```{r make-map}
set.seed(ran_seed)
map_from_table <- make.acmap(titer_table = data1, number_of_dimensions = 2, number_of_optimizations = 100)

set.seed(ran_seed)
map_from_map <- optimizeMap(map = map, number_of_dimensions = 2, number_of_optimizations = 100)
```

If you a sensible reason, you can fix the column base:

```{r fixed-col-base}
set.seed(ran_seed)
map_fixed_col_base <- optimizeMap(map = map, number_of_dimensions = 2, fixed_column_bases = rep(8, 21), number_of_optimizations = 100)
```

Or set a minimum column base:

```{r min-col-base}
set.seed(ran_seed)
map_min_col_base <- optimizeMap(map = map, number_of_dimensions = 2, minimum_column_basis = "1280", number_of_optimizations = 100)
```

You can also make a map in 3D. We will check later if this is a good idea.

```{r map3d}
set.seed(ran_seed)
map_3d <- optimizeMap(map = map, number_of_dimensions = 3, number_of_optimizations = 100)
```

### Merging tables

Remember when merging tables that names & IDs need to be identical

Here I'm generating artificial data to show the principles of merging data. You don't need to worry about this step when analysing data.

```{r simulating-data}
set.seed(ran_seed)
data2 <- 10*2^round(logtiterTable(map)+rnorm(length(logtiterTable(map)), mean=0, sd=0.5))
data2[data2<20] <- "<20"
data2[data2=="NaN"] <- "*"
dimnames(data2) <- dimnames(data1)
map2 <- acmap(titer_table= data2)
```

The simplest method is to merge table together. You can also give the function a list of maps to merge.

```{r merging-tables}
merge_table <- mergeMaps(map, map2, method="table")
merge_map <- optimizeMap(merge_table, 2, 100)
```

If you already have a map, you can merge your new data in either by using the original map as a starting point, or freezing the original map and then merging new data in (this can be useful when you are merging mutants in and want to keep the background map consistent). I won't demonstrate the frozen merge here as the two datasets completely overlap

```{r other-merge}
merge_incremental <- mergeMaps(map_from_map, map2, method="incremental-merge", number_of_dimensions = 2, number_of_optimizations = 100)
```

## Plotting a map

```{r plot}
plot(map_from_map, plot_stress=T)

ggplot(map_from_map, plot_stress=T)

view(map_from_map)
```

### Adding sequence data

Sequence data is added as a matrix, so if you start with a fasta file you will need to do a little pre-processing (aligning and trimming your sequences & then changing from a list to a matrix).

```{r seq data}
ag_sequences <- read.csv(
  file = system.file("extdata/h3map2004_sequences_ag.csv", package = "Racmacs"),
  colClasses = "character",
  row.names = 1
)

sr_sequences <- read.csv(
  file = system.file("extdata/h3map2004_sequences_sr.csv", package = "Racmacs"),
  colClasses = "character",
  row.names = 1
)

agSequences(map_from_map) <- ag_sequences[agNames(map_from_map),]
srSequences(map_from_map) <- sr_sequences[srNames(map_from_map),]

```

### Colours, shapes and sizes

Color, shape, size, outline colour and outline width can be customised for antigens and sera. A few examples below.

```{r}
# color by year
yr <- as.numeric(paste0(c(rep("19", 36), rep("20", 13)), sapply(strsplit(agNames(map_from_map), split="/", fixed=T), "[[", 3)))
agFill(map_from_map) <- rainbow(12)[yr-1992]

view(map_from_map)

agFill(map_from_map) <- "grey60"
# color by genetics
agFill(map_from_map)[agSequences(map_from_map)[,156]=="K"] <- "forestgreen"
agFill(map_from_map)[agSequences(map_from_map)[,156]=="Q"] <- "skyblue"
agFill(map_from_map)[agSequences(map_from_map)[,156]=="H"] <- "gold"

agSize(map_from_map)[c("PM/2007/99", "SY/5/97", "NA/933/95", "WU/359/95")] <- 10

agShape(map_from_map)[c(36, 29, 11, 13)] <- "EGG"
srShape(map_from_map)[c("PM/2007/99", "SY/5A/97", "SY/5B/97", "SY/5HAY/97", "SY/5V/97", "NA/933/95","WU/359B/95")] <- "UGLYEGG"

view(map_from_map)
```

## Quality assurance

### Stress 

```{r stress}
mapStress(map_from_map)

plot(allMapStresses(map_from_map))
```

```{r more-optimisation}
mapStress(map_from_map)

ams <- allMapStresses(map_from_map)
plot(ams)
```

We can also compare stress between different merging methods

```{r merges}
mapStress(merge_map)
mapStress(merge_incremental)
```

### Viewer features (connection lines, error lines, stress dots)

```{r viewer}
view(map_from_map)
```

### Procrustes

We use procrustes to compare two maps with antigens & sera in common.

First, we need to get another map to compare with (in that I need to remoce the antigen & serum IDs from the 2004 map so that the algorithm matches by name).

```{r get-2004-map}
map_2004 <- read.acmap("data/seq-t9a-mod27.ace")
srIDs(map_2004) <- rep("", numSera(map_2004))
agIDs(map_2004) <- rep("", numAntigens(map_2004))
```

```{r procrustes}
map_from_map <- realignMap(map_from_map, map_2004)
pc <- procrustesMap(map_from_map, map_2004)

pc_data <- procrustesData(map_from_map, map_2004)
names(pc_data)
pc_data$total_rmsd
```   

We can also perform a procrustes to the other optimisations and plot this.

```{r self-procrustes}
pc_rmsd <- rep(NA, numOptimizations(map_from_map))
for (i in 1:numOptimizations(map_from_map)){
  pc_rmsd[i] <- procrustesData(map_from_map, map_from_map, 1, i)$total_rmsd
}

plot(pc_rmsd)

plot(ams, pc_rmsd)
```

### Point uncertainty (blob)

Point uncertainty can be visualised using bootsrapping where data is randomly excluded and the map re-made. Here I've used the default parameters of 1000 repeats and 100 optimisations per repeat. I've commented out the code as it might take a while to run on your machine - you can simply load the completed map for plotting.

There's more detail on the bootstrapping methods [here](https://acorg.github.io/Racmacs/articles/assessing_map_uncertainty.html)

```{r blob}
# set.seed(ran_seed)
# bs_map <-bootstrapMap(map_from_map, method = "resample")
# save.acmap(bs_map, "out/bs_map.ace")
# blob95 <- bootstrapBlobs(bs_map, , conf.level=0.95)
# blob68 <- bootstrapBlobs(bs_map)
# blob10 <- bootstrapBlobs(bs_map, conf.level=0.1)
# save.acmap(blob95, "out/blob95_map.ace")
# save.acmap(blob68, "out/blob68_map.ace")
# save.acmap(blob10, "out/blob10_map.ace")

blob68 <- read.acmap("out/blob68_map.ace")
plot(blob68, plot_stress=T)
view(blob68)

blob10 <- read.acmap("out/blob10_map.ace")
plot(blob10, plot_stress=T)
view(blob10)
```

### Dealing with warnings

Firstly, we can exclude the antigens that are uncoordinated and giving the first warning.

```{r avoid-reliability-warning}
map_from_map_rm <- removeAntigens(map_from_map, c('EN/7/94', 'FI/339/95'))
set.seed(ran_seed)
map_from_map_rm <- optimizeMap(map = map_from_map_rm, number_of_dimensions = 2, number_of_optimizations = 100)

pc <- procrustesMap(map_from_map_rm, map_from_map_rm, 1, 2)
view(pc)
```

Then we can remove other antigens that are potentially poorly coordinated

```{r try-avoid-unstable-warning}
hist(rowSums(data1!="*"), xlab="Number of measured data points per antigen", breaks=1:20)

map_from_map_rm2 <- removeAntigens(map_from_map, which(rowSums(data1!="*")<4))
set.seed(ran_seed)
# map_from_map_rm2 <- optimizeMap(map = map_from_map_rm2, number_of_dimensions = 2, number_of_optimizations = 100)

map_from_map_rm2 <- removeSera(map_from_map_rm2, 'MA/G252/93')
set.seed(ran_seed)
map_from_map_rm2 <- optimizeMap(map = map_from_map_rm2, number_of_dimensions = 2, number_of_optimizations = 100)

pc <- procrustesMap(map_from_map_rm2, map_from_map_rm2, 1, 2)
view(pc)
```

We still have an unstable map; what does this mean?

## FAQs

### How to get distance from all points?

```{r dist}
dist_mat <- as.matrix(dist(ptCoords(map_from_map)))
```


### How to handle repeated sera?

If they are technical replicates (i.e. the same serum sample, titrated more than one), then I would recommend merging before antigenic cartography (assuming that the replicates are sufficiently similar).

